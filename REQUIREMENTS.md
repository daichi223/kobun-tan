# 古文クイズアプリケーション 要件定義書
Ver. 5.0 (最終・実装版)

**作成日:** 2025年10月9日

## 1. 概要
本ドキュメントは、古文クイズアプリケーションにおけるユーザー解答の自動採点機能、文法フィードバック機能、および関連するUI/UXに関する全要件を定義するものである。

本システムは、記述形式で入力されたユーザーの現代語訳を、あらかじめ定義された正解データと照合し、人間の採点感覚に近い精緻な評価とスコアリングを行うことを目的とする。評価は**「意味の中心核（語幹）」と「文法的なニュアンス（付属語）」を分離して行い、スコアとは別に「文法的な正しさ」**も検証する。さらに、解答結果に応じたインタラクティブな学習フローを提供することで、ユーザーの主体的で深い学びを促進する。

## 2. システム構成と責務
本システムは、責務の分離の原則に基づき、以下のモジュールで構成される。このアーキテクチャは、保守性、拡張性、およびロジックの明確性を最大化するために設計されている。

| ファイル名 | 役割 | 詳細な責務 |
|----------|------|-----------|
| kobun_q.jsonl.txt | 問題データ 📖 | クイズの問題と、その文脈における正解の中心的な意味 (sense) を定義する。アプリケーションの知識の源泉であり、人間が可読・編集可能な形式を維持する。senseには解答の本質部分のみを記述する。 |
| morphTokenizer.ts | 形態素解析エンジン 🔬 | 日本語文字列を、**語幹（lemma）と付属語タグの集合（aux）に動的に分解・構造化する**。現代語の表現揺れを古文の文法タグに正規化し、多義性を持つ助動詞を複合タグとして表現する責務を負う。 |
| matchSense.ts | 採点エンジン ✍️ | morphTokenizerによって構造化されたユーザー解答と正解データを比較し、後述する精緻な採点アルゴリズムに基づき0点から100点までのスコアを算出することに専念する。 |
| kobun-grammar.json | 文法ルールブック 🧐 | 動詞の活用や助動詞の接続規則など、網羅的な文法データを定義する。直接の採点には関与しないが、採点後に解答の文法的な正しさを検証し、質の高いフィードバックを生成するための参照データとして機能する。 |
| App.tsx | アプリケーション本体 🖥️ | UIの表示、ユーザー操作の受付、各モジュールの呼び出し、そして**「採点結果」と「文法検証結果」**を統合してユーザーに提示するなど、アプリケーション全体の動作を制御する司令塔。 |

## 3. コアロジック(1)：採点エンジン matchSense.ts 詳細設計

### 3.1. 思想
採点は、まず**「意味の中心核（語幹=lemma）が合っているか」を最重要事項として判定し、次に「文法的なニュアンス（付属語=aux）をどれだけ正確に再現できているか」**を評価する、2段階のアルゴリズムを採用する。

### 3.2. 前提となるmorphTokenizer.tsの仕様
- **出力形式**: `{ lemma: string; aux: Set<string>; }` という形式のオブジェクトを生成する。複合タグ（例: 完了-存続）は、この段階で分割され、`Set {"完了", "存続"}` のように集合に格納される。
- **正規化**: 全角・半角の統一、括弧類の除去などの前処理を行う。
- **タグ定義**: `ないで→打消-接続` のように、機能が明確な表現は専用の複合タグを割り当てる。

### 3.3. 評価アルゴリズム (実装レベル詳細)
評価は以下のシーケンスで上から順に実行され、最初に合致した条件のスコアを返し、処理を終了する。

```typescript
// 疑似コード: matchSense(userAnswer: string, correctSense: string): { score: number; reason: string }

// --- 初期化フェーズ ---
const ansMorph = morphKey(userAnswer);      // {lemma: "見る", aux: {"打消"}}
const correctMorph = morphKey(correctSense); // {lemma: "見る", aux: {"打消", "接続"}}

// --- 評価フェーズ ---

// ステップ1: 語幹 (lemma) の評価
if (ansMorph.lemma !== correctMorph.lemma) {
  if (isSimilarButWrong(ansMorph.lemma, correctMorph.lemma)) {
    return { score: 60, reason: "類義語の誤用" };
  } else {
    return { score: 0, reason: "文脈違い" };
  }
}

// ステップ2: 付属語 (aux) の評価 (語幹が一致していることが前提)
const ansTags = ansMorph.aux;
const correctTags = correctMorph.aux;

if (ansTags.size === 0 && correctTags.size === 0) {
  return { score: 90, reason: "語幹のみ正解" };
}

const missingTags = new Set([...correctTags].filter(t => !ansTags.has(t)));
const extraTags = new Set([...ansTags].filter(t => !correctTags.has(t)));

if (missingTags.size === 0 && extraTags.size === 0) {
  return { score: 100, reason: "完全一致" };
}

if (missingTags.size === 1 && missingTags.has("接続")) {
  return { score: 85, reason: "接続部分の欠落" };
}

if (missingTags.size === 0 && extraTags.size > 0) {
  return { score: 75, reason: "過剰な解釈" };
}

// 上記のいずれにも当てはまらない場合、それは必須要素の欠落とみなす
return { score: 65, reason: "必須要素の欠落" };
```

### 3.4. スコア定義表

| スコア | 評価パターン | 詳細な条件 | 具体例 (sense → 解答) |
|--------|-------------|-----------|----------------------|
| 0点 | 文脈違い | 解答の語幹が、正解の語幹と全く異なる | おどろく (気づく) → 目を覚ます |
| 60点 | 類義語の誤用 | 語幹は異なるが、意味的に近い単語リストに該当 | 心苦し (相手が気の毒だ) → つらい (自分がつらい) |
| 65点 | 必須要素の欠落 | 語幹は一致、必須の付属語が欠落 | 似たる (完了+存続) → 似る (付属語なし) |
| 75点 | 過剰な解釈 | 語幹と必須付属語は一致、余分な意味を追加 | 見えで (打消) → 見られないで (可能+打消) |
| 85点 | 接続部分の欠落 | 語幹と主要付属語は一致、接続タグのみ欠落 | 見えで (打消+接続) → 見ない (打消のみ) |
| 90点 | 語幹のみ正解 | 両方に付属語なし、語幹が完璧に一致 | あはれなり → しみじみと趣深い |
| 100点 | 完全一致 | 語幹と付属語が完全に一致 | 見えで → 見ないで |

## 4. コアロジック(2)：文法フィードバック機能 App.tsx への統合

### 4.1. 処理フロー
1. ユーザーが解答を提出
2. App.tsx は、まず `matchSense.ts` を呼び出し、スコアと採点理由を取得
3. 次に App.tsx は、スコアとは独立して、`kobun-grammar.json` を参照する検証関数（例: `validateConnections`）を呼び出し、ユーザー解答の文法的な正しさをチェック
4. 検証関数は、文法的な問題点のリスト（例: `["助動詞「ず」は未然形に接続します"]`）を返す。問題がなければ空の配列を返す
5. App.tsx は、スコアと文法問題点のリストの両方をStateとして保持し、UIに表示

### 4.2. App.tsx の状態管理
```typescript
// App.tsxのState（概念）
const [matchResults, setMatchResults] = useState<{ [qid: string]: { score: number; reason: string; } }>({});
const [grammarIssues, setGrammarIssues] = useState<{ [qid: string]: string[] }>({}); // 文法エラーを保持
```

## 5. UIおよびインタラクションフロー要件

### 5.1. 出題形式
- **見出し語（lemma）単位での出題**: 同一の見出し語を持つ例文を1セットの問題としてまとめて出題する
- **例文のランダム表示**: セット内の例文は、セッションごとにランダムな順序で表示する

### 5.2. 解答後の画面フロー
- **結果表示**: 採点スコアと、文法的な問題があれば「文法のヒント💡」を併せて表示する
- **自己採点機能**: スコアが**60点以上90点以下**の場合、ユーザーが自身の判断で正誤を修正できる**「〇（正解にする）」「×（不正解にする）」ボタン**を表示する

### 5.3. 次の問題への遷移ロジック
- **自動遷移**: セット内のすべての問題で**100点**を獲得した場合、自動的に次の問題セットへ遷移する
- **手動遷移**: セット内に1つでも90点以下の問題が存在する場合（自己採点で「×」にした場合も含む）、「次へ」ボタンを表示する。ユーザーは自身のペースで復習した後、手動で次に進む

## 6. データ要件

### kobun_q.jsonl.txt
- 必須フィールドは `qid`, `lemma`, `sense`
- `sense` は自然な文字列とする

### kobun-grammar.json
- 動詞の活用、助動詞の接続ルールなどを網羅した構造化データとする

## 7. 非機能要件
- **パフォーマンス**: 解答提出から結果表示までの応答時間は500ms以内を目指す
- **保守性**: 採点基準の変更や文法ルールの追加が、影響範囲を最小限に抑えて容易に行えること
- **拡張性**: 将来的に品詞分解クイズなどを追加する際に、既存モジュールを再利用できる設計であること

## 8. 実装状況

### 8.1. データソース
- `public/kobun500.tsv`: 単語データ
- `public/multiple-meaning-words.tsv`: 多義語データ
- `src/assets/kobun-grammar.json`: 文法規則データ

### 8.2. 実装済み機能
- ✅ morphTokenizer.ts: 連用形音便（っ/ん/い）を接続タグとして認識
- ✅ matchSense.ts: 7段階評価（100, 90, 85, 75, 65, 60, 0点）
- ✅ 文法検証: validateConnectionsFromFile.ts による文法チェック
- ✅ UI: スコア表示、文法のヒント、○×ボタン、自動/手動遷移
- ✅ localStorage: モード選択、範囲設定の永続化

### 8.3. アーキテクチャの特徴
1. **責務の分離**: 採点（matchSense）と文法検証（validateConnections）は独立
2. **形態素解析の精度**: kobun-grammar.jsonを参照し、活用形を正確に処理
3. **2段階評価**: 語幹→付属語の順で段階的に評価
4. **複合タグのサポート**: 「打消-接続」「完了-存続」などを正確に処理
5. **類義語誤用検出**: similarButWrongPairs による60点判定
